import sys\nclass FastScanner:\n    def __init__(self):\n        self.inp = sys.stdin.read().split()\n\n    def nextInt(self):\n        return int(self.inp.pop(0))\n\n    def nextLong(self):\n        return int(self.inp.pop(0))\n\nclass Main:\n    INF = float('inf') // 2\n    MOD = 1_000_000_007\n    SIZE = 1_000_000\n    fac = [0] * SIZE\n    inv = [0] * SIZE\n    finv = [0] * SIZE\n\n    def __init__(self):\n        self.sc = FastScanner()\n\n    def solve(self):\n        n = self.sc.nextInt()\n        m = self.sc.nextInt()\n        map_ = {}\n\n        for i in range(m):\n            s = self.sc.nextInt()\n            c = self.sc.nextInt()\n            if s in map_ and map_[s] != c:\n                print(-1)\n                sys.exit(0)\n            map_[s] = c\n\n        for i in range(1000):\n            s = str(i)\n            flag = True\n            if len(s) < n:\n                continue\n            for j in range(n):\n                if (j + 1 in map_ and map_[j + 1] != int(s[j])) or (j + 1 not in map_ and int(s[j]) != 0):\n                    if j == 0 and j + 1 not in map_ and int(s[j]) == 1:\n                        continue\n                    flag = False\n                    break\n            if flag and len(s) == n:\n                print(s)\n                sys.exit(0)\n\n        print(-1)\n\n    def gcd(self, a, b):\n        if b == 0:\n            return a\n        return self.gcd(b, a % b)\n\n    def lcm(self, a, b):\n        return a * b // self.gcd(a, b)\n\n    def inv(self, a):\n        return self.pow(a, self.MOD - 2)\n\n    def pow(self, a, r):\n        sum_ = 1\n        while r > 0:\n            if r & 1:\n                sum_ *= a\n                sum_ %= self.MOD\n            a *= a\n            a %= self.MOD\n            r >>= 1\n        return sum_\n\n    def modFact(self, n):\n        if n == 0:\n            return 1\n        return n * self.modFact(n - 1) % self.MOD\n\n    def fact(self, n):\n        if n == 0:\n            return 1\n        return n * self.fact(n - 1)\n\n    def initCOMB(self):\n        self.fac[0] = self.fac[1] = 1\n        self.inv[1] = 1\n        self.finv[0] = self.finv[1] = 1\n        for i in range(2, self.SIZE):\n            self.fac[i] = self.fac[i - 1] * i % self.MOD\n            self.inv[i] = self.MOD - self.inv[self.MOD % i] * (self.MOD // i) % self.MOD\n            self.finv[i] = self.finv[i - 1] * self.inv[i] % self.MOD\n\n    def modComb(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fac[n] * self.finv[r] % self.MOD * self.finv[n - r] % self.MOD\n\n    def comb(self, n, r):\n        num = 1\n        for i in range(1, r + 1):\n            num = num * (n - i + 1) // i\n        return num\n\n    def isPrime(self, a):\n        if a <= 1:\n            return False\n        for i in range(2, int(a**0.5) + 1):\n            if a % i == 0:\n                return False\n        return True\n\n    def nextPermutation(self, s):\n        list_ = list(s)\n        pivotPos = -1\n        pivot = 0\n        for i in range(len(list_) - 2, -1, -1):\n            if list_[i] < list_[i + 1]:\n                pivotPos = i\n                pivot = list_[i]\n                break\n\n        if pivotPos == -1 and pivot == 0:\n            return None\n\n        L = pivotPos + 1\n        R = len(list_) - 1\n        minPos = -1\n        min_ = chr(127)\n        for i in range(R, L - 1, -1):\n            if pivot < list_[i]:\n                if list_[i] < min_:\n                    min_ = list_[i]\n                    minPos = i\n\n        list_[pivotPos], list_[minPos] = list_[minPos], list_[pivotPos]\n        list_[L:R + 1] = sorted(list_[L:R + 1])\n\n        return ''.join(list_)\n\n    def nextPermutation(self, a):\n        for i in range(len(a) - 1, 0, -1):\n            if a[i - 1] < a[i]:\n                swapIndex = self.find(a[i - 1], a, i, len(a) - 1)\n                a[swapIndex], a[i - 1] = a[i - 1], a[swapIndex]\n                a[i:] = sorted(a[i:])\n                return True\n        return False\n\n    def find(self, dest, a, s, e):\n        if s == e:\n            return s\n        m = (s + e + 1) // 2\n        return self.find(dest, a, s, m - 1) if a[m] <= dest else self.find(dest, a, m, e)\n\n    def elimination(self, a, b):\n        n = len(a)\n        for k in range(n - 1):\n            for i in range(k + 1, n):\n                f = -a[i][k] / a[k][k]\n                for j in range(k + 1, n):\n                    a[i][j] += f * a[k][j]\n                b[i] += f * b[k]\n            for i in range(n - 1, -1, -1):\n                for j in range(i + 1, n):\n                    b[i] -= a[i][j] * b[j]\n                b[i] /= a[i][i]\n\nif __name__ == "__main__":\n    main = Main()\n    main.solve()\n# End of Code
